\startreport{Lazy Data generation in Q}
\reportauthor{Ramesh Subramonian}
\newcommand{\Assign}{\verb+:=+ }

\section{Introduction}

For now, I am being blase in mixing Lua and C but this is pseudo-code 
so I will take the liberty of doing so.

\TBC


\section{How is data represented?}
There are two ways data is represented. One is as a vector,
Section~\ref{data_vector}. The other is as a coroutine,
Section~\ref{data_coroutine}. We have utilities to convert from one to
the other. In other words, given a co-routine, it should be possible
to create a vector. Given a vector, we should be able to create a
co-routine that can be used to consume the data of the vector in
chunks.

\subsection{Data as a vector}
\label{data_vector}

A vector consists of the following
\be
\item {\bf M1}, a Lua table which contains mandatory meta-data such as 
\be
\item {\bf cdata}, \verb+char *+, a pointer to a region of {\bf contiguous} memory
containing data 
\item {\bf filename}, \verb+char []+, The name of the file where cdata has been
persisted, if at all. 

At least one of cdata and filename must be non-null.
If filename is defined and cdata is null, then mmap can be used to set cdata. If
cdata is defined and filename is null, then this memory was obtained from
malloc()
and has not yet been persisted to disk.
%----------------------
\item {\bf nncdata}, \verb+char *+, a pointer to a region of {\bf contiguous} memory
containing boolean information about whether corresponding data is null or not.
As an implementation detail, this is stored as bytes, although it could be
stored as bits. In particular, nncdata[i] can be either 0 or 1 where 
1 means that the \(i^{th}\) value is not null and 
0 means that the \(i^{th}\) value is null. 

\item {\bf nnfilename}, \verb+char []+, The name of the file where nncdata has been
persisted, if at all. 

It is possible for nncdata and nnfilename to both be null.
%----------------------
\item {\bf len}, \verb+ssize_t+. number of elements
\item {\bf isnn}, \verb+bool+, whether there are null values. 

If isnn = true, then either nncdata or nnfilename should be non-null
If isnn = false, then both nncdata and nnfilename should be null
%-------
\item {\bf fldtype}, how to interpret the memory. We intend to support 6 types.
In the near  future, will extend to constant length strings and then unsigned integers. 
\begin{verbatim}
int8_t, int16_t, int32_t, int64_t, float, double
\end{verbatim}

\item {\bf sz}, \verb+ssize_t+ size of each element. This is sizeof(fldtype) and
hence this is redundant except when the fldtype is ``constant length
string''.
\ee
\item {\bf M2}, a Lua table which contains optional meta-data such as 
\be
\item min, max, sum, \ldots
\item number of null values. If this is 0, then nncdata and nnfilename must be
null. It is possible for this to be nil and one of nncdata and nnfilename to be
defined. This means we {\em may} have null values but haven't calculated that as
yet. 
\item number of distinct values
\item md5hash of data, used as a check that data has not gotten corrupted
\item filesz, size of file referenced in filename. Used for checking.

Note that the size of the file, if one exists, may be set to a
multiple of the file block size and hence may be greater than
required.
\item nnfilesz, size of file referenced in nnfilename. Used for checking.
\item \ldots
\ee


\ee

\subsection{Data as a co-routine}
\label{data_coroutine}
It is useful to have the ability to have a co-routine that offers up
consecutive chunks of memory from a vector to a consumer. 


\subsection{Creating a vector from a co-routine}
\label{vec_from_coro}

Figure~\ref{eval} describes eval(), the function used to create a
vector from a coroutine.

\begin{figure}
\centering
\fbox{
\begin{minipage}{20cm}
\begin{tabbing} \hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= \kill
FILE *fp = NULL, *nnfp = NULL; \\
char filename[] = "/tmp/myfileXXXX", nnfilename[] = "/tmp/myfileXXXX"; \\
int clock = 0; \\
ssize\_t len = 0; \\
prev = nil; \\ 
M1, M2 = coroutine.resume(x, -1);  /* Get meta data */ \\
/* If resume of x returns a scalar, then M2 will be null; else, a table,
even if an empty one */ \\
{\bf if not} M2 {\bf then} isvec = true {\bf else} isvec = false {\bf endif} \\
{\bf if } isvec {\bf then} \+ \\ 
mktemp(filename); fp = fopen(filename, "wb"); \\
{\bf if} M1.isnn {\bf then} \+ \\
  mktemp(nnfilename); nnfp = fopen(nnfilename, "wb"); \- \\
{\bf endif} \- \\
{\bf endif} \\
%---------------------------------------------
{\bf for} ( ; ; ) {\bf do}  /* while chunks to consume */ \+ \\
  rslt = coroutine.resume(x, clock); \\
  {\bf if} {\bf not} rslt  {\bf then} /* prepare for return */ \+ \\
    {\bf if not} prev  {\bf then} \+ \\
      error("first invocation cannot return nil")' \- \\
    {\bf endif} \\
    {\bf if} isvec {\bf then} \+ \\ 
      if ( fp != NULL ) { fclose(fp); } \\
      if ( nnfp != NULL ) { fclose(nnfp); } \\
      local x = \{\} \\
      x.isnn = M1.isnn \\
      x.filename = filename \\
      x.fldtype = M1.fldtype \\
      x.sz = M1.sz; \\
      x.len = x; \\
      {\bf if } M1.isnn {\bf then} x.nnfilename = nnfilename {\bf endif} \\
      return x; \- \\
    {\bf else}  \+ \\ 
      return prev; \- \\
    {\bf endif} \- \\
  {\bf endif} \\
  {\bf if} isvec {\bf then} \+ \\
    len += rslt.len; /* Cumulative length of vector */ \\
    fwrite(rslt.cdata, rslt.len, sizeof(rslt.fldtype), fp); \- \\
  {\bf endif} \\ 
  clock++; \\
  prev = rslt; \- \\
{\bf endfor}
\end{tabbing}
\end{minipage}
}
\label{eval}
\caption{Function eval(x)}
\end{figure}

\subsection{Creating a co-routine from a vector}
\label{coro_from_vec}
Figure~\ref{wrap} describes wrap(), the function used to create a
coroutine from a vector.  The details of the function used to create
the co-routine are in Figure~\ref{wrap}.
\begin{verbatim}
q['wrap'] = function (invec)
  return coroutine.create(
    function(clock)
      ...
    end
  )
\end{verbatim}
\begin{figure}
\centering
\fbox{
\begin{minipage}{20cm}
\begin{tabbing} 
\hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= 
\hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= 
\kill
local o = \{\} ; \\
local lclock = 0; \\
{\bf while} clock \(\neq\) nil and clock \(<\) 0 {\bf then} \+ \\
  coroutine.yield(o, invec.M1, invec.M2) \- \\
{\bf endif} \\
local X = invec.cdata; \\
{\bf if} ( not X ) {\bf then} \+ \\ 
  local struct stat filestat; \\
  int fd = open(invec.filename, O\_RDONLY); \\
  fstat(fd, \&filestat); filesz = filestat.st\_size; \\
  assert(invec.len \(\times\) sizeof(invec.fldtype) \(\geq\) filesz) ; \\
  X = mmap(NULL, filesz, PROT\_READ, fd, 0); \- \\
{\bf endif} \\ 
{\bf for} ( ever ) {\bf do} \+ \\ 
  lclock++; lclock = clock or lclock; \\
  local ssize\_t lb = (clock-1) \(\times\) chunksize \\
  {\bf if } lb \(>\) len {\bf then return} {\bf endif} \\
  local ssize\_t ub = min(len, lb + chunksize) \\
  o.cdata = X + ( lb \(\times\) sizeof(invec.fldtype) ) \\
  o.len   = (ub - lb); \\ 
  o.fldtype = invec.fldtype; \\
  o.sz = invec.sz; \\
  coroutine.yield(o, x.M1, x.M2) \\
{\bf while} clock \(\neq\) nil and clock \(<\) 0 {\bf then} \+ \\
  coroutine.yield(o, invec.M1, invec.M2) \- \\
{\bf endif} \- \\
{\bf endfor} 
\end{tabbing}
\end{minipage}
}
\label{wrap}
\caption{Function wrap(x)}
\end{figure}

\subsection{An example: add} 
\label{example_add}

let us consider the function add which returns a co-routine that will yeild up
chunks of the results of adding two ``things'', whether they be vectors or
co-routines. 
The details of the function used to create the co-routine for add in
Figure~\ref{add}. 
\begin{verbatim}
q['add'] = function (arg1, arg2)
  return coroutine.create(
    function()
    end
  )
\end{verbatim}

\begin{figure}
\centering
\fbox{
\begin{minipage}{20cm}
\begin{tabbing} \hspace*{0.25in} \= \hspace*{0.25in} \= \hspace*{0.25in} \= \kill
{\bf if}  ( typeof(arg1) == "vector" ) {\bf then} arg1 = wrap(arg1) {\bf endif} \\
{\bf if}  ( typeof(arg2) == "vector" ) {\bf then} arg2 = wrap(arg2) {\bf endif} \\
assert( typeof(arg1) == "coroutine" ) \\
assert( typeof(arg2) == "coroutine" ) \\
f3sz, f3type, cfn = somefn(arg1, arg2) \TBC \\
f3 = \{\}; f3.sz = f3sz; f3.fldtype = f3type;  \\
f3.cdata = C.malloc(f3sz \(\times\) chunksize) \\
{\bf do} forever \+ \\ 
c1 = coroutine.resume(arg1) \\
c2 = coroutine.resume(arg1) \\
assert((c1 and c2) or (not c1 and not c2)) \\
{\bf if} ( not c1 ) {\bf then} return {\bf endif} \\ 
C.cfn(c1.cdata, c2.cdata, f3cdata) \\
coroutine.yield(f3) \- \\
{\bf endfor} \\
\end{tabbing}
\end{minipage}
}
\label{add}
\caption{Function used to create co-routine for add(x, y)}
\end{figure}



\section{The new assignment operator and peval}
\label{assign_op}

Assume that we have an operator \verb+:=+, which works as follows. Its
meaning is different based on whether we are operating in basic or
advanced mode.  In basic mode, a \verb+:=+ b is the same as a =
eval(b), Figure~\ref{eval}. In advanced mode, a \verb+:=+ b is the same
as a = nop(b) where nop is a function that just returns its argument.


