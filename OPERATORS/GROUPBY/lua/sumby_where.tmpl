return require 'Q/UTILS/lua/code_gen' {

   declaration = [[

#include "q_incs.h"
#include "_get_bit_u64.h"
${includes}
extern int
${fn}(  
      const ${val_ctype} * const restrict val_fld,  
      uint64_t nR_v,
      const ${grpby_ctype} * const restrict grpby_fld,  
      uint64_t nR_g,
      const uint64_t * const restrict cond_fld, 
      ${out_ctype} * restrict out_fld,
      bool is_safe
      ) 
;

   ]],
   definition = [[

#include "_${fn}.h"

int
${fn}(  
      const ${val_ctype} * const restrict val_fld,  
      uint64_t nR_v,
      const ${grpby_ctype} * const restrict grpby_fld,  
      uint64_t nR_g,
      const uint64_t * const restrict cond_fld, 
      ${out_ctype} * restrict out_fld,
      bool is_safe
      )

{ 
  int status = 0;

  if ( is_safe ) {
#pragma omp parallel for schedule(static, 1024)
    for ( uint64_t i = 0; i < nR_v; i++ ) {
      ${grpby_ctype} grpby = grpby_fld[i];
      if ( ( grpby < 0 ) || ( grpby >= (${out_ctype})nR_g ) ) { 
        status = -1;
      }
    }
    cBYE(status);
  }

#pragma omp parallel for schedule(static, 1024)
  for ( uint64_t i = 0; i < nR_v; i++ ) { 
    // TODO: Don't use a function call to extract the bits
    if ( get_bit_u64(cond_fld, i) == 1 ) {
      ${val_ctype} val = val_fld[i];
      ${grpby_ctype} grpby = grpby_fld[i];
      out_fld[grpby] += val;
    }
  }
BYE:
  return status;
}
   ]]
}
