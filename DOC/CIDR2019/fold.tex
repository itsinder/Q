\subsection{Fold}
\label{fold}
Consider the case where we want to perform many different reductions (e.g., min,
max, sum, \ldots) over the same vector. The simple way to do this is
\begin{verbatim}
x = Q.sum(w); y = Q.min(w); z = Q.max(w)
\end{verbatim}
However, this necessitates several scans over the vector \(w\). It is more
efficient to evaluate the vector \(w\) a chunk at a time, perform all the
reductions on the chunk, store the partial results and then repeat over
successive chunks. So, we can re-write the above as 
{\tt x, y, z = Q.fold({ "sum", "min", "max" }, w)}
where the fold operator is 
\begin{verbatim}
-- f_to_s is a table consisting of all reducers registered with Q
local f_to_s = require 'Q/OPERATORS/F_TO_S/lua/_f_to_s'
local function fold( fns, vec)
  local status
  -- setup reducers for each input 
  local gens = {} 
  for i, v in ipairs(fns) do 
    gens[i] = f_to_s[v](vec) 
  end
  -- for each chunk, evaluate reducer on that chunk
  repeat 
    for i, v in ipairs(fns) do 
      status = gens[i]:next() 
    end 
  until not status
  -- return results for each reducer in return_vals
  local return_vals = {}
  for i, v in ipairs(gens) do 
    return_vals[i] = gens[i]:eval() 
  end
  return unpack(return_vals)
end
\end{verbatim}
We try to avoid memo-izing vectors when we don't have to because 
of the cost of flushing to disk. In our experiments, for \(n > 2^{25}\), 
memo-izing the input \(w\) and computing min/max/sum sequentially 
is {\em six} times slower than using the fold operator.
