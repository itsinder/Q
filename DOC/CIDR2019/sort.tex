\subsection{The social graph}
\label{social_graph}

One of the problems we investigated at LinkedIn was using the social graph to
guide and power the design of data-driven products.
Assume that a social graph is presented as a 
a table, {\tt E}, with 2 columns, {\tt from} and {\tt to}. Q supports the
creation of auxiliary data structures to enable fast access but, in keeping with
our minimalist philosophy, does not prvoide them out of the box.
\be
\item Assume {\tt E} is sorted, {\tt from} as primary key and {\tt to} as
  secondary key (Section~\ref{par_sort}). Efficient parallel sort is discussed
  in Section~\ref{par_sort}.
\item 
  {\tt E.idx = Q.sequence({start = 0, incr = 1, qtype = I4})}
creates a Vector with values \(0, 1, \ldots\) 
\item {\tt V.m = Q.unique(E.from)} creates a Vector of 
member IDs, sorted ascending. 
\item {\tt V.lb = Q.join(E.from, E.idx, V.m, min)}
and {\tt V.ub = Q.join(E.from, E.idx, V.m, max)}
allow us to quickly identify the contiguous edges of a given member. Member
{\tt m = V.m[i]} is connected to members {\tt E.to[V.lb[i] \ldots E.to[V.ub[i]}
\ee


\subsubsection{Speeding up sort}
\label{par_sort}
Consider a simple parallelization of the sort routine. Assume that we 
``magically'' know a set of mutually exclusive and exhaustive intervals such
that each interval would get ``roughly'' the same number of elements of an input
Vector \(x\). Then a simple parallel sort consists of 
(1) partitioning \(n\) elements of \(x\) into \(n_B\) bins so that each bin has
\(n(b)\) elements
(2) sorting each bin in parallel
(3) copying each bin into the right place. Probabilistic guarantees
of the form \(P[n(b) \geq (1+\beta) \times(n/n_B)] \leq \epsilon\) 
allow us to allocate slightly more space than absoutely necessary and to 
fall back to the sequential sort in the small probability that our estimates are off.

To support this, the {\tt Q.sort} operator accepts ``hints'' in the form of
optional arguments. In this case, the hint is a Vector whose length is the
number of bins and each element is the upper bound of that bin. For Vectors of
length greater than \(2^{20}\), we obtained linear speedup on an Intel Core i7.

To quote George Santayana, ``those who don't remember the past are condemned to
repeat it''.  \Q\ minimizes re-work in several ways
\be
\item 
Remembering basic statistics such as min, max, sum, average, whenever the
corresponding operators are invoked. 
\item the sorted-ness of a vector is
stored as one of (a) unknown (b) ascending (c) descending (d) not sorted. \Q\
uses sort heavily to simplify other operators by converting them into linear
scans. For example, consider {\tt x, y  = Q.count(z)} where \(x\) contains the
unique values of \(z\) and \(y\) the number of occurrences. If \(z\) is not
sorted, then the count operator internally (a) creates a copy, \(z'\), of \(z\)
(b) sorts \(z'\) (c) passes \(z'\) to the count sub-routine and (d) \(z'\) gets
garbage collected when the count operator returns. Of course, if \(z\) is
sorted, then this overhead is eliminated.

\ee
