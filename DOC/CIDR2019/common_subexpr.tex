\section{Choreographing computations}

One of the main ways by which large data systems are optimized is minimizing the
amount of data that is moved around, as is reflected by the large body of work in
both academia and industry around optimzing compilers. 

Q takes a fundamentally different approach. It is our belief that the
choreography of computations is best left to the database programmer. This is
possible if the database programmer has (i) some understanding of the underyling
system architecture and (ii) relatively simple knobs to influence the run time
system.  In this section, we use a number of examples to illustrate this point.


\subsection{Fold}
Consider the case where we want to perform many different reductions (e.g., min,
max, sum, \ldots) over the same vector. The simple way to do this is
\begin{verbatim}
x = Q.sum(w); y = Q.min(w); z = Q.max(w)
\end{verbatim}
However, this necessitates several scans over the vector \(w\). It is more
efficient to evaluate the vector \(w\) a chunk at a time, perform all the
reductions on the chunk, store the partial results and then repeat over
successive chunks. So, we can re-write the above as 
\begin{verbatim}
x, y, z = Q.fold({ "sum", "min", "max" }, w)
\end{verbatim}
where the fold operator is 
\begin{verbatim}
-- f_to_s is a table consisting of all reducers registered with Q
local f_to_s = require 'Q/OPERATORS/F_TO_S/lua/_f_to_s'
local function fold( fns, vec)
  local status
  local gens = {}
  -- setup reducers for each input 
  for i, v in ipairs(fns) do gens[i] = f_to_s[v](vec) end
  -- for each chunk, evaluate reducer on that chunk
  repeat 
    for i, v in ipairs(fns) do status = gens[i]:next() end 
  until not status
  -- return results for each reducer in return_vals
  local return_vals = {}
  for i, v in ipairs(gens) do return_vals[i] = gens[i]:eval() end
  return unpack(return_vals)
end
\end{verbatim}


\subsection{Common sub-expression elimination}

As part of the gradient descent algorithm used in logistic regression
(Section~\ref{XXXX}), the following expressions need to be
calculated 
\begin{equation}
\label{logit}
  \frac{1}{1 + e^{-x}}
\end{equation}
\begin{equation}
\label{logit2}
    \frac{1}{(1 + e^{-x})^2}
\end{equation}
To implementing this in Q, we first 
recognize that these operations are of the form ``\(y \leftarrow f(x)\)''. This
allows us to re-use the templates for those data flow patterns to auto-generate
code and create 
custom operators {\tt logit} and {\tt logit2}. 
Therefore, the simplest implementation would be
\begin{verbatim}
y = Q.logit(x); z = Q.logit2(x)
\end{verbatim}
However, that leads to a lot
of redundant computations.  This can be eliminated as follows
\begin{verbatim}
t1 = Q.vsmul(x, Scalar.new(-1, fldtype)):memo(false)
t2 = Q.exp(t1):memo(false)
t3 = Q.incr(t2):memo(false)
t4 = Q.sqr(t3):memo(false)
y  = Q.reciprocal(t3)
z  = Q.reciprocal(t4)
\end{verbatim}

However, notice that using the above code introduces a subtle but
critical bug when the number of elements in \(x\) exceeds the chunk
size.  If we were to call {\tt eval()} on \(y\), then we would
end up consuming sucessive chunks of \(t_3\). Now, if we were to call
{\tt eval()} on \(z\), we would fail when requesting the first
chunk of \(t_3\), since it has {\bf not} been memo-ized. One solution
is to ensure that \(y\) and \(z\) are evaluated in lock-step, after they have
been created, as shown below.
\begin{verbatim} 
  cidx = 0  -- chunk index
  repeat 
    ly = y:chunk(cidx)
    lz = z:chunk(cidx)
    assert(ly == lz)
    cidx = cidx + 1
  until ( ly == 0 )
\end{verbatim}

However, this solution suffers from the drawback that it requires \(y\) and
\(z\) to be evaluated before they are returned to the calling function.
In other words, the following code would lead to an error, unless {\tt foo} had
fully evaluated \(y\) and \(z\) as described above.
\begin{verbatim}
y, z = foo(x); y:eval(); z:eval()
\end{verbatim}

We would prefer that the Q programmer to be able to
inform the system that \(y\) and \(z\) need to be evaluated in lock-step 
and not have to write the {\tt repeat} loop shown above. This leads to the
following solution

\begin{verbatim}
y:set_memo(false); z:set_memo(false);  -- no memo-izing needed
conjoin({y, z}) -- indicate that they need to be evaluated together
assert(z:is_eov() == false) -- z not fully evaluated
y:eval() -- evaluate y when needed
assert(z:is_eov() == true) -- z fully evaluated as a consequence of y eval
\end{verbatim}
