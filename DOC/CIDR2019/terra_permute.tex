\section{Operator polymorphism in Q}

Vectorized operators in Q are intrinsically overloaded i.e. the same Q operator (Lua function) can be invoked with vectors of any of the supported Q data-types [\ref{vectors}].
Overloading is achieved as follows.
\be
\item static compilation: In this case, the operator writer implements
  templatized C-like code. At build time, the template is fleshed out for all
  relevant combinations of data types to generate the \verb+.c+ and \verb+.h+
  files, which are then compiled into a single \verb+.so+.
\item dynamic compilation: 
  In this case too, we require the existence of templates. 
  The server starts up with a minimal set of core functionality. 
  However, the generation of the source file, compiling and loading
  are done on demand. The results are cached
  so that subsequent calls to the same operator do not incur this overhead.

  {\em Need to talk about what happens when  the server starts up again. Where
  are the .so files and the .h files kept and cdef'd}

\item we define a function for a particular combination of data types
  dynamically, in a strongly typed language, that can bind seamlessly
  with the host language (Lua, in our case). 
  {\bf SRINATH to explain above in more detail.}
  This was done using the Terra
  language, details in Section \ref{Terra} 
  \ee

\subsection{Terra} 
\label{Terra} 
Terra is ``a low-level system programming language that is embedded in and
meta-programmed by the Lua programming language'' \cite{devito15xx}
Terra offered the best of both worlds, the performance of compiled code
with the dynamic typing of a scripting language.
To evaluate Terra in context of Q, we implemented the {\tt permute()} operator, described below, using Terra.

The \(permute\) operator applies an index \(\mathrm{idx}\) vector to an input vector \(x\)
to produce a permuted variant \(y\) of \(x\). 
If \(y = \mathrm{Q.permute}(x, \mathrm{idx}, \mathrm{mode})\) and \(x = \{10, 20, 30\}\) and
\(\mathrm{idx} = \{2, 1,
0\}\), then \(y = \{30, 20, 10\}\).
It comes in two variants:
(a) 
Gather : \(y[i] \leftarrow x[\mathrm{idx}[i]]\) and (b) 
Scatter: \(y[\mathrm{idx}[i]] \leftarrow x[i]\) 

\begin{figure}
\centering
\fbox{
\begin{minipage}{12 cm}
\centering
\verbatiminput{terra_code}
\caption{Terra code for gather/scatter variations of permute}
\label{permute_in_terra}
\end{minipage}
}
\end{figure}

Figure~\ref{permute_in_terra} shows the Terra function used to implement it.
Note the memoization of the function definition; thus given the combination of requisite data types, the Terra function is defined on-demand (lazily) and memoized for future usage.

In order to invoke the Terra function (Figure\ref{permute_in_terra} from Q, we
need to map Q's data types to Terra. This is done with a simple global 
array, \verb+q_to_terra+ such that, for example, 
\verb+q_to_terra['I4'] = int32_t+

Q's permute operator, which uses the Terra function of
Figure~\ref{permute_in_terra} 
is presented in Figure~\ref{permute_in_Q}. 
Given a vector of type {\tt val\_qtype} and an index vector, it 
returns a vector of type {\tt val\_qtype}.
The code has been heavily edited in the interest of brevity.

\begin{figure}
\centering
\fbox{
\begin{minipage}{12 cm}
\centering
\verbatiminput{q_permute_code}
\caption{Q code for permute}
\label{permute_in_Q}
\end{minipage}
}
\end{figure}

In conclusion,
the combination of Terra and Lua enables a powerful programming paradigm for dynamically compiled function definitions, and has potential for significantly improving the implementation-speed and maintainability of the operator implementations. 
However, it is
still an immature technology. Using it within the Lua runtime causes sever
performance degradation. Simply including the statement 
{\tt require('terra')} causes upto 50\% degradation even when no Terra code is
used. 

