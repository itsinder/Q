\startreport{Q: A Developer's Guide}
\reportauthor{Ramesh Subramonian}

\section{Introduction}

The aim of this document is to provide a step-by-step guide to being a
library developer, working on the internals of Q. We will also
discuss how packaging and installation are done and how to operate as
a Q developer. A Q developer need have {\bf no} idea about the
internals of Q --- it is just another Lua package. Of course,
understanding the internals, to some extent, allows for more efficient
usage of the Q primitives.

Remember, we have 2 distinct roles
\be
\item Library developer: The folks developing the Q library 
\item Q programmer aka user: The developers who'll use the Q library
\ee
Note these are just roles, the same person can play both.

\section{Getting Started}
\label{getting_started}

\subsection{Building your machine for the first time}

Starting with a minimal Ubuntu install, you should execute Indrajeet \TBC

Check that we are building LuaJIT with pthread in Make. \TBC



\subsection{Environment Variables}
\label{env_var}
So, you want to modify the guts of Q? Here's a step by step guide.

\be
\item Say, you are in \verb+/home/subramon/WORK/+ 
\item \verb+git clone https://github.com/NerdWalletOSS/Q.git+
\item Set the following environment variables
using \verb+source setup.sh -f+. Note that this is just a convenience. If you
want, you can set them yourself but then the onus is on you to get things right.
These are
\be
\item \verb+QC_FLAGS+ --- these will be used as flags to gcc when creating
\verb+.o+ files
\item\verb+Q_LINK_FLAGS+ --- these will be used as flags to gcc when creating
\verb+.so+ files
\item \verb+Q_ROOT+ ---  This is where artifacts created by the build provess
will be stored. As of now, they are
\be
\item \verb+Q_ROOT/lib/+ --- contains \verb+libq_core.so+
\item \verb+Q_ROOT/include/+ --- contains \verb+q_core.h+
\item \verb+Q_ROOT/tmpl/+ --- contains templates, used for dynamic code
generation
\ee
\item \verb+Q_DATA_DIR+ --- This is where data files will be stored. Think of
this as a tablespace and keep a separate one for each project you are working
\item \verb+Q_METADATA_DIR+ --- This is where meta data files will be stored. Think of
this as a tablespace and keep a separate one for each project you are working
on. Default will be \verb+Q_ROOT/meta/+
\item 
\verb+LD_LIBRARY_PATH+ Make sure that this includes \verb+Q_ROOT/lib/+ This is
where \verb+libq_core.so+ will be created
\item \verb+ LUA_PATH+, Section~\ref{masquerade}
\ee
\ee

\subsubsection{Consequences}

There are some important consequences of the above. 
\be
\item {\bf Do  not set} these environment variables in any of your scripts.
\item {\bf Do not use} \verb+Q_ROOT+ anywhere except in \verb+Q/UTILS/build+
\item In your Lua scripts, you must specify the entire path of the file you want
to require e.g.,
\begin{center}
{\tt local foo = require 'Q/UTILS/lua/foo' }
\end{center}
\item Use the following conventions for your require's. We will explain each
one below.
\begin{verbatim}
local qconsts = require 'Q/UTILS/lua/q_consts'
local ffi     = require 'Q/UTILS/lua/q_ffi'
local qc      = require 'Q/UTILS/lua/q_core'
\end{verbatim}
\be
\item qconsts contains constants
\item qc contains all C functions that are accessible to Lua. See  Section~\ref{two_kinds_c_functions}.
\item ffi is the same as on \url{http://luajit.org}. 
\ee
\ee


\subsection{Building}

\subsubsection{Two kinds of C functions}
\label{two_kinds_c_functions}
C programs are used to augment Lua in two important ways
\be
\item to help with code generation and to perform some functionality that 
could not be done easily (or in a performant manner) in Lua. Examples
of these are text converters like \verb+txt_to_I8+ or \verb+get_cell+
\item the computational workhorse. This is where the heavy lifting happens.
\ee

\subsubsection{Breaking circular dependency}
You will note a bit of a circular dependency. We need C code to create
C code.  This is broken in one of two ways
\be
\item Execute \verb+Q/UTILS/mk_core_so.lua+ This creates the following 
files 
\be
\item \verb+Q_ROOT/include/q_core.h+ --- which is used for \verb+ffi.cdef()+
\item \verb+Q_ROOT/lib/q_core.so+ --- which is used for \verb+ffi.load()+
\ee
You are have the C functionality needed for code generation

\item Within \verb+Q/UTILS/build/+, do {\tt make clean; make} 
\ee

\subsection{Registering an operator}

When you create an operator, a functionality that will be used by the Q
programmer e.g, add, sort, \ldots, you need to {\em register} that in the
following manner. Consider \verb+mk_col+ as an example

\begin{verbatim}
local Q       = require 'Q/q_export'
local mk_col = function(input, qtype)
......
return require('Q/q_export').export('mk_col', mk_col)
\end{verbatim}

You need to know a few things to understand the underlying mechanism
\be
\item 
\verb+Q_SRC_ROOT/init.lua+ is called when Q programmer does 
\verb+require ('Q')+
\item \verb+ q_export+ is the table that Q programmer will use
\ee



\subsection{Masquerading as a Q developer}
\label{masquerade}

From time to time, you will need to pretend to be a Q developer so that you can
test your code. To enable this to happen without re-installing Q, you set
\verb+LUA_PATH+ as below. Note the double semi-colon at the end. That is needed.
Srinath to fill in the gaps \TBC
\begin{verbatim}
/home/subramon/WORK/?.lua;;+
/home/subramon/WORK/?/init.lua;;
\end{verbatim}
First one above is current, second is Srinath's. Resolve difference \TBC

\subsection{Installation}

At some point in the not too distant future, Q will be installed as 
\begin{verbatim}
sudo luarocks install Q
\end{verbatim}
Until then, it is installed as 
\begin{verbatim}
cd $Q_SRC_ROOT; sudo bash q_install.sh 
\end{verbatim}
%$
\subsection{Usage}

The Q developer does not need to set any of the environment variables of
Section~\ref{env_var}, except for 
\verb+Q_DATA_DIR, Q_METADATA_DIR+, which {\em must} be set. 
In an earlier version, we had required them
to set \verb+LUA_INIT+. That is no longer needed.
A sample Q script looks as follows
\begin{verbatim}
Q = require 'Q'
x = Q.mk_col({10, 20, 30, 40}, 'I4')
Q.print_csv(x, nil, "")
os.exit()
\end{verbatim}

If you want to change the environment variables, 
\verb+Q_DATA_DIR, Q_METADATA_DIR+, this means that you want to work on a
different project or tablespace. In that case, 
\be
\item \verb+Q.save()+
\item exit the script 
\item reset the environment variables
\item restart the Q server or execute a new script
\ee

\section{Lua Coding Conventions}
This section deals with coding conventions to be followed by a library developer
writing Lua code. 
\be
\item Do {\bf not} pollute the global name space. So, all variables are {\bf
local}.
\item Do not use {\tt dofile}. Use {\tt require instead}
\item LuaJIT scripts that invoke pthreads (indirectly) should end with
\verb+os.exit()+
\ee

\appendix

\section{LuaJIT and OpenMP}

Ciprian Tomoiaga wrote:
{\it I have a C function containing OpenMP clause which I call with ffi. On my
machine, the program terminates with a segmentation fault. However, it
works without a problem on a Mac and on another machine. }

Mike Pall responded: 
The most likely cause is the dreaded pthread issue: the main
executable must be compiled/linked with -pthread (note: this is
not the same as -lpthread!). Otherwise a shared library which is
loaded later on and uses threads may cause a crash.
The easiest way to test this hypothesis is to rebuild LuaJIT with:
\begin{verbatim}
  make TARGET_FLAGS=-pthread
\end{verbatim}
and then try again.

Ciprian Tomoiaga wrote:
{\it I recompiled with the specified opition, but it still crashes. :(
Do I have any other options? }

Mike Pall responded: 
Well I tried myself and it prints two lines, but then crashes when
the shared library is unloaded (as a consequence of \verb+lua_close()+).
Looks like OpenMP doesn't like to be unloaded --- this never
happens with programs that are statically linked against it.

